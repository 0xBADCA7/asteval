
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Motivation for asteval &#8212; ASTEVAL: Minimal Python AST evaluator</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using asteval" href="basics.html" />
    <link rel="prev" title="Downloading and Installation" href="installation.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Using asteval"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Downloading and Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ASTEVAL: Minimal Python AST evaluator</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Motivation for asteval</a><ul>
<li><a class="reference internal" href="#how-safe-is-asteval">How Safe is asteval?</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Downloading and Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="basics.html"
                        title="next chapter">Using asteval</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/motivation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="motivation-for-asteval">
<h1>Motivation for asteval<a class="headerlink" href="#motivation-for-asteval" title="Permalink to this headline">¶</a></h1>
<p>The asteval module allows you to evaluate a large subset of the Python
language from within a python program, without using <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>.  It
is, in effect, a restricted version of Python’s built-in <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>,
forbidding several actions, and using using a simple dictionary as a flat
namespace.  A completely fair question is: Why is this desirable?  That
is, why not simply use <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>, or just use Python itself?</p>
<p>The short answer is that sometimes you want to allow evaluation of user
input, or expose a simple calculator inside a larger application.  For
this, <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> is pretty scary, as it exposes <em>all</em> of Python, which
makes user input difficult to trust.  Since asteval does not support the
<strong>import</strong> statement (or many other constructs), user code cannot access
the <a class="reference external" href="https://docs.python.org/2/library/os.html#module-os" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> and <a class="reference external" href="https://docs.python.org/2/library/sys.html#module-sys" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> modules or any functions or classes
outside the provided symbol table.</p>
<p>Other missing features (modules, classes, lambda, yield, generators) are
similarly motivated by a desire for a safer version of <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>.
The idea for asteval is to make a simple procedural, mathematically
oriented language that can be embedded into larger applications.</p>
<p>In fact, the asteval module grew out the the need for a simple expression
evaluator for scientific applications such as the <a class="reference external" href="http://github.com/lmfit/lmfit-py">lmfit</a> and <a class="reference external" href="http://github.com/xraypy/xraylarch">xraylarch</a>
modules.  A first attempt using the pyparsing module worked but was
error-prone and difficult to maintain.  It turned out that using the Python
<a class="reference external" href="https://docs.python.org/2/library/ast.html#module-ast" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a> module is so easy that adding more complex programming
constructs like conditionals, loops, exception handling, complex assignment
and slicing, and even user-defined functions was fairly simple to
implement.  Importantly, because parsing is done by the <a class="reference external" href="https://docs.python.org/2/library/ast.html#module-ast" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a>
module, whole classes of implementation errors disappear.  Valid python
expression will be parsed correctly and converted into an Abstract Syntax
Tree.  Furthermore, the resulting AST is easy to walk through, greatly
simplifying evaluation over any other approach.  What started as a desire
for a simple expression evaluator grew into a quite useable procedural
domain-specific language for mathematical applications.</p>
<p>Asteval makes no claims about speed. Obviously,  evaluating the ast tree
involves a lot of function calls, and will likely be slower than Python.
In preliminary tests, it’s about 4x slower than Python.  For certain use
cases (see <a class="reference external" href="https://stackoverflow.com/questions/34106484">https://stackoverflow.com/questions/34106484</a>), use of asteval
and numpy can approach the speed of <cite>eval</cite> and the <cite>numexpr</cite> modules.</p>
<div class="section" id="how-safe-is-asteval">
<h2>How Safe is asteval?<a class="headerlink" href="#how-safe-is-asteval" title="Permalink to this headline">¶</a></h2>
<p>Asteval avoids the known exploits that make <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> dangerous. For
reference, see, <a class="reference external" href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">Eval is really dangerous</a> and
the comments and links therein.  From this discussion it is apparent that
not only is <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> unsafe, but that it is a difficult prospect to
make any program that takes user input perfectly safe.  In particular, if a
user can cause Python to crash with a segmentation fault, safety cannot be
guaranteed.  Asteval explicitly forbids the exploits described in the above
link, and works hard to prevent malicious code from crashing Python or
accessing the underlying operating system.  That said, we cannot guarantee
that asteval is completely safe from malicious code.  We claim only that it
is safer than the builtin <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>, and that you might find it
useful.</p>
<p>Some of the things not allowed in the asteval interpreter for safety reasons include:</p>
<blockquote>
<div><ul class="simple">
<li>importing modules.  Neither ‘import’ nor ‘__import__’ are supported.</li>
<li>create classes or modules.</li>
<li>access to Python’s <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>, <a class="reference external" href="https://docs.python.org/2/library/functions.html#execfile" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">execfile()</span></code></a>,
<a class="reference external" href="https://docs.python.org/2/library/functions.html#getattr" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>, <a class="reference external" href="https://docs.python.org/2/library/functions.html#hasattr" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a>, <a class="reference external" href="https://docs.python.org/2/library/functions.html#setattr" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a>, and
<a class="reference external" href="https://docs.python.org/2/library/functions.html#delattr" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">delattr()</span></code></a>.</li>
</ul>
</div></blockquote>
<p>In addition (and following the discussion in the link above), the following
attributes are blacklisted for all objects, and cannot be accessed:</p>
<blockquote>
<div>__subclasses__, __bases__, __globals__, __code__, __closure__, __func__,
__self__, __module__, __dict__, __class__, __call__, __get__,
__getattribute__, __subclasshook__, __new__, __init__, func_globals,
func_code, func_closure, im_class, im_func, im_self, gi_code, gi_frame
f_locals, __mro__</div></blockquote>
<p>This approach of making a blacklist cannot be guaranteed to be complete,
but it does eliminate classes of attacks known to seg-fault the Python.  On
the other hand, asteval will typically expose numpy ufuncs from the numpy
module, and several of these can seg-fault Python without too much trouble.
If you’re paranoid about safe user input that can never cause a
segmentation fault, you’ll want to disable the use of numpy.</p>
<p>There are important categories of safety that asteval does not even attempt
to address. The most important of these is resource hogging, which might be
used for a denial-of-service attack.  There is no guaranteed timeout on any
calculation, and so a reasonable looking calculation such as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">asteval</span> <span class="k">import</span> <span class="n">Interpreter</span>
<span class="n">aeval</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">()</span>
<span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;nmax = 1e8</span>
<span class="s2">a = sqrt(arange(nmax))</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">aeval</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</pre></div>
</div>
<p>can take a noticeable amount of CPU time.  It is not hard to come up with
short program that would run for hundreds of years, which probably exceeds
anyones threshold for an acceptable run-time.  As a very simple example, it
is very hard to predict how long the expression <cite>x**y**z</cite> will take to run
without knowing the values of <cite>x</cite>, <cite>y</cite>, and <cite>z</cite>.   In short, runtime cannot
be determined lexically.</p>
<p>For a limited range of problems, you can try to avoid asteval taking too
long.  For example, you may try to limit the <em>recursion limit</em> when
executing expressions, with a code like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">limited_recursion</span><span class="p">(</span><span class="n">recursion_limit</span><span class="p">):</span>
    <span class="n">old_limit</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="n">recursion_limit</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="n">old_limit</span><span class="p">)</span>

<span class="k">with</span> <span class="n">limited_recursion</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">Interpreter</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also pass in a <cite>max_time</cite> (in seconds) when you create an asteval
Interpreter, wich will try to limit the amount of time an expression will
take.  This is actually of limited utility, since the calculation must
return to the asteval interpreter for the runtime to be checked at all.  Many
long-running calculations will be stuck deep inside C-code evaluated by the
Python interpreter itself, and not return or allow other threads to run
until that calculation is done. That is, from within a single process,
there really is not a foolproof way to tell asteval to have a maximum
runtime.  The most reliable way to put a firm limit on runtime is to have a
second process watching the execution time of the asteval process and
interrupt or kill it.</p>
<p>In summary, while asteval attempts to be safe and is definitely safer than
using <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>, there are many ways that asteval could be considered
part of an un-safe programming environment.  Recommendations for how to
improve this situation would be greatly appreciated.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Using asteval"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Downloading and Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ASTEVAL: Minimal Python AST evaluator</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, Matthew Newville, The University of Chicago.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>